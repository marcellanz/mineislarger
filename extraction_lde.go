
/*
 This file was autogenerated via
 -----------------------------------------------
 ldetool generate --little-endian extraction.lde
 -----------------------------------------------
 do not touch it with bare hands!
*/

package main

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

var commaSpace = []byte(", ")

// Extraction ...
type Extraction struct {
	Rest  []byte
	Col1  []byte
	Col2  []byte
	Col3  []byte
	Col4  []byte
	Time  uint64
	Col6  []byte
	State []byte
	Name  []byte
}

// Extract ...
func (p *Extraction) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until '|' as Col1(string)
	pos = bytes.IndexByte(p.Rest, '|')
	if pos >= 0 {
		p.Col1 = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as Col2(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Col2 = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as Col3(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Col3 = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as Col4(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Col4 = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as Time(uint64)
	pos = bytes.IndexByte(p.Rest, '|')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("cannot parse `%s` into field Time(uint64): %s", *(*string)(unsafe.Pointer(&tmp)), err)
	}
	p.Time = uint64(tmpUint)

	// Take until '|' as Col6(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Col6 = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as State(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.State = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '|' as Name(string)
	pos = bytes.IndexByte(p.Rest, '|')
	if pos >= 0 {
		p.Name = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// Name ...
type Name struct {
	Rest  []byte
	Last  []byte
	First []byte
}

// Extract ...
func (p *Name) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until ", " as Last(string)
	pos = bytes.Index(p.Rest, commaSpace)
	if pos >= 0 {
		p.Last = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(commaSpace):]
	} else {
		return false, nil
	}

	// Take until ' ' (or all the rest if not found) as First(string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		p.First = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		p.First = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}

	return true, nil
}
